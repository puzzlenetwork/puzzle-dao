{-# STDLIB_VERSION 6 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}

let stakingAddress = Address(base58'3P7dGTVZp8VLDYy3XEaUQbiqfi9cMK1Ly5q')
let parametersAddress = Address(base58'3PPhk65Ab4UDgbxYUDW7YSXkzHfWtj7WBrB')

let Scale8 = 100000000

func tryGetInteger(key: String) = match getInteger(this, key) {
    case b: Int => 
        b
    case _ => 
        0
}

func tryGetBoolean(key: String) = match getBoolean(this, key) {
    case b: Boolean => 
        b
    case _ => 
        false
}

func tryGetString(key: String) = match getString(this, key) {
    case b: String => 
        b
    case _ => 
        ""
}

func calculateSRate() = {
  # SRate = interest earned on 1 PLUTO 
  strict stakingEmission = match invoke(parametersAddress, "getStakingBlockEmission", [false], []) {
    case in: Int => in
    case _ => throw("bad invoke")
  }

  let lastCheckSRate = getIntegerValue(stakingAddress, "global_lastCheckSRate")
  let sPlutoAmount =  getIntegerValue(stakingAddress, "global_sPluto")
  let lastCheckHeight =  getIntegerValue(stakingAddress, "global_lastCheckSRateHeight")
  let blocks = height - lastCheckHeight
  if (sPlutoAmount == 0) then {Scale8} else {
    getIntegerValue(stakingAddress, "global_lastCheckSRate") + fraction(blocks * Scale8, stakingEmission, sPlutoAmount)
  }
}


let li100 = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"] # , "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100"]
let batches = ["1", "2", "3", "4"]
let availableOptions = ["1", "2", "3"]


@Callable(i)
func vote(option: String, votingId: String) = {
  let voteId = votingId
  let addressStr = toString(i.caller)
  let randomHash = sha256(i.transactionId)
  let batch = toString((1 + (toInt(randomHash) % size(batches))))
  let voteValueStr = option
  if (availableOptions.indexOf(option) == unit) then {throw("incorrect option is chosen")}
  else if (!tryGetBoolean(voteId+"_status")) then {throw("voting is not active")}
  else if (tryGetString(voteId + "_" + addressStr) != "")
    then throw("you already voted")
    else [
      StringEntry(voteId + "_" + voteValueStr + "_batch" + batch, tryGetString(voteId + "_" + voteValueStr + "_batch" + batch) + addressStr + ","), 
      StringEntry(voteId + "_" + addressStr, voteValueStr)
    ]
}


@Callable(i)
func results(votingId: String, debug: Boolean) = {
  func batchHandler(accum: (Int, Int, Int), batch: String) =     {
    strict inv = invoke(this, "batchResults", [batch, votingId], nil)
    let new = match inv {
        case x: (Int, Int, Int) => x
        case _ => throw("error in batch "+batch)
    }
    (accum._1 + new._1, accum._2 + new._2, accum._3 + new._3)
  }

  let sRate = calculateSRate()
  let res = FOLD<4>(batches, (0, 0, 0), batchHandler)

  if debug then {
    throw("votes result " + toString(fraction(res._1, sRate, Scale8)) + ", " + toString(fraction(res._2, sRate, Scale8)) + ", " + toString(fraction(res._3, sRate, Scale8)))
  } else {
    ([], (fraction(res._1, sRate, Scale8), fraction(res._2, sRate, Scale8), fraction(res._3, sRate, Scale8)))
  }
}


@Callable(i)
func batchResults(batch: String, votingId: String) = {
  func votesHandler(accum: Int, addressStr: String) = (
    accum + (match getInteger(stakingAddress, (addressStr + "_sPluto")) {
    case x: Int => 
        x
    case _ => 
        0
  }))

  let li1 = split(tryGetString(votingId + "_1_batch" + batch), ",")
  let votes1 = FOLD<90>(li1, 0, votesHandler)

  let li2 = split(tryGetString(votingId + "_2_batch" + batch), ",")
  let votes2 = FOLD<90>(li2, 0, votesHandler)

  let li3 = split(tryGetString(votingId + "_3_batch" + batch), ",")
  let votes3 = FOLD<90>(li3, 0, votesHandler)

  ([], (votes1 / Scale8, votes2 / Scale8, votes3 / Scale8))
}


@Callable(i)
func setVotingStatus(votingId: String, active: Boolean) = {
  if (this != i.caller) then {throw("admin only")}
  else {
    [
      BooleanEntry(votingId+"_status", active)
    ]
  }
}

@Callable(i)
func startVoting(title: String, desc: String, duration: Int, options: String) = {
  if (this != i.caller) then {throw("admin only")}
  else {
    func checkIdAvailable(accum: String, next: String) = {if accum == "0" && getBoolean(next+"_status") == unit then next else accum}
    let votingId = FOLD<100>(li100, "0", checkIdAvailable)

    [
      BooleanEntry(votingId+"_status", true),
      StringEntry(votingId+"_title", title),
      StringEntry(votingId+"_description", desc),
      StringEntry(votingId+"_proposer", i.caller.toString()),
      IntegerEntry(votingId+"_startTime", lastBlock.timestamp),
      IntegerEntry(votingId+"_endTime", lastBlock.timestamp + duration),
      StringEntry(votingId+"_options", options)
    ]
  }
}

@Callable(i)
func getData(debug: Boolean) = {
  # id,title,status,description,proposer,start_time,end_time,option1|option2|option3,votes1|votes2|votes3
  func addVotingData(accum: String, votingId: String) = {
    let status = getBoolean(votingId+"_status")
    if (status == unit) then {accum} else {
      strict result = (invoke(this, "results", [votingId, false], [])).exactAs[(Int, Int, Int)]

      accum + votingId + "," + tryGetString(votingId+"_title") + "," + status.value().toString() + "," + tryGetString(votingId+"_description") + "," + tryGetString(votingId+"_proposer") 
      + "," + tryGetInteger(votingId+"_startTime").toString() + "," + tryGetInteger(votingId+"_endTime").toString() + "," + tryGetString(votingId+"_options")
      + "," + result._1.toString() + "|" + result._2.toString() + "|" + result._3.toString() + ";"
    }
  }

  let res = FOLD<10>(li100, "", addVotingData)

  if (debug) then {throw(res)}
  else {([], res)}
}

